# -*- coding: utf-8 -*-
"""SEToforder2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aaVNthZ01DhU6HgwyK_QQurZh1BmbMfW
"""

import numpy as np

# -- Gussian window
def g_window(length, freq, factor):     #factor = window width factor; greater the factor better the resolution of s-transform
  vector = []
  vector.append(np.linspace(0,length-1,length))
  vector.append(np.linspace(-length,-1,length))
  vector = np.array(vector)
  vector = vector**2

  vector = vector * (-2 * np.pi**2 * factor / freq**2)
  g = np.exp(vector)

  return np.sum(g, axis=0)

# -- s transform using gaussian window
def St(x,fSamp,t,factor):
  n=len(x)

  freq= np.fft.rfftfreq(n,d=(1/fSamp))
  fsr=freq[1]-freq[0]

  X=np.fft.fft(x)
  X= np.concatenate((X,X))

  minfreq = 0
  maxfreq = fSamp/2

  st=[]

  st.append(np.mean(x) * np.ones(n))

  for i in range(int(maxfreq/fsr)):
    #st(banana/freqsamplingrate+1,:)=ifft(vector_fft(minfreq+banana+1:minfreq+banana+n).*g_window(n,minfreq+banana,factor));
    temp = np.fft.ifft(X[i:i+n] * g_window(n, (i+1)*fsr, factor))
    st.append(temp)

  st = np.array(st)
  return freq,t,st


# -- Time derivative gaussian window
def dg_window(length, freq, factor):
  vector = []
  vector.append(np.linspace(0,length-1,length))
  vector.append(np.linspace(-length,-1,length))
  vector = np.array(vector)
  v = vector
  vector = vector**2

  vector = vector * (-2 * np.pi**2 * factor / freq**2)
  g = np.exp(vector)

  g = g * v * (2 * np.pi * 1j)

  return np.sum(g, axis=0).imag

# -- s-transform using the time derivative gaussian window
def dSt(x,fSamp,t,factor):
  n=len(x)

  freq= np.fft.rfftfreq(n,d=(1/fSamp))
  fsr=freq[1]-freq[0]

  X=np.fft.fft(x)
  X= np.concatenate((X,X))

  minfreq = 0
  maxfreq = fSamp/2

  st=[]

  st.append(np.mean(x) * np.ones(n))

  for i in range(int(maxfreq/fsr)):
    #st(banana/freqsamplingrate+1,:)=ifft(vector_fft(minfreq+banana+1:minfreq+banana+n).*g_window(n,minfreq+banana,factor));
    temp = np.fft.ifft(X[i:i+n] * dg_window(n, (i+1)*fsr, factor))
    st.append(temp)

  st = np.array(st)
  return freq,t,st

# -- Synchroextraction
def SET(x,fSamp,t,factor=3,threshold=1.):

  fx,tx,st=St(x,fSamp,t,factor)
  fx,tx,dst=dSt(x,fSamp,t,factor)

  dd = np.abs(1j*dst/st)

  se = np.where(np.fix (dd) <= threshold , st, 0.0) 

  return tx,fx,st,se


# -- Time double derivative gaussian window
def ddg_window(length, freq, factor):
  vector = []
  vector.append(np.linspace(0,length-1,length))
  vector.append(np.linspace(-length,-1,length))
  vector = np.array(vector)
  v = vector
  vector = vector**2

  vector = vector * (-2 * np.pi**2 * factor / freq**2)
  g = np.exp(vector)

  g = g * v * v * (2 * np.pi * 1j)**2

  return np.sum(g, axis=0).imag


# -- s-transform using the time double derivative gaussian window
def ddSt(x,fSamp,t,factor):
  n=len(x)

  freq= np.fft.rfftfreq(n,d=(1/fSamp))
  fsr=freq[1]-freq[0]

  X=np.fft.fft(x)
  X= np.concatenate((X,X))

  minfreq = 0
  maxfreq = fSamp/2

  st=[]

  st.append(np.mean(x) * np.ones(n))

  for i in range(int(maxfreq/fsr)):
    #st(banana/freqsamplingrate+1,:)=ifft(vector_fft(minfreq+banana+1:minfreq+banana+n).*g_window(n,minfreq+banana,factor));
    temp = np.fft.ifft(X[i:i+n] * ddg_window(n, (i+1)*fsr, factor))
    st.append(temp)

  st = np.array(st)
  return freq,t,st

# -- Time multiplied gaussian window
def tg_window(length, freq, factor):
  vector = []
  vector.append(np.linspace(0,length-1,length))
  vector.append(np.linspace(-length,-1,length))
  vector = np.array(vector)
  v = vector
  vector = vector**2

  vector = vector * (-2 * np.pi**2 * factor / freq**2)
  g = np.exp(vector)

  g = g * v * (-2 * np.pi * 1j)

  return np.sum(g, axis=0).imag


# -- s-transform using the time multiplied gaussian window
def tSt(x,fSamp,t,factor):
  n=len(x)

  freq= np.fft.rfftfreq(n,d=(1/fSamp))
  fsr=freq[1]-freq[0]

  X=np.fft.fft(x)
  X= np.concatenate((X,X))

  minfreq = 0
  maxfreq = fSamp/2

  st=[]

  st.append(np.mean(x) * np.ones(n))

  for i in range(int(maxfreq/fsr)):
    #st(banana/freqsamplingrate+1,:)=ifft(vector_fft(minfreq+banana+1:minfreq+banana+n).*g_window(n,minfreq+banana,factor));
    temp = np.fft.ifft(X[i:i+n] * tg_window(n, (i+1)*fsr, factor))
    st.append(temp)

  st = np.array(st)
  return freq,t,st

# -- Time multiplied time derivative gaussian window
def tdg_window(length, freq, factor):
  vector = []
  vector.append(np.linspace(0,length-1,length))
  vector.append(np.linspace(-length,-1,length))
  vector = np.array(vector)
  v = vector
  vector = vector**2

  vector = vector * (-2 * np.pi**2 * factor / freq**2)
  g = np.exp(vector)

  g = g * v * v* (2 * np.pi * 1j)**2 * (-1)

  return np.sum(g, axis=0).imag


# -- s-transform using the time multiplied time derivative gaussian window
def tdSt(x,fSamp,t,factor):
  n=len(x)

  freq= np.fft.rfftfreq(n,d=(1/fSamp))
  fsr=freq[1]-freq[0]

  X=np.fft.fft(x)
  X= np.concatenate((X,X))

  minfreq = 0
  maxfreq = fSamp/2

  st=[]

  st.append(np.mean(x) * np.ones(n))

  for i in range(int(maxfreq/fsr)):
    #st(banana/freqsamplingrate+1,:)=ifft(vector_fft(minfreq+banana+1:minfreq+banana+n).*g_window(n,minfreq+banana,factor));
    temp = np.fft.ifft(X[i:i+n] * tdg_window(n, (i+1)*fsr, factor))
    st.append(temp)

  st = np.array(st)
  return freq,t,st

# -- Synchroextraction of order 2
def SET2(x,fSamp,t,factor=3,threshold=1.):

  fx,tx,st=St(x,fSamp,t,factor)
  fx,tx,dst=dSt(x,fSamp,t,factor)
  fx,tx,ddst=ddSt(x,fSamp,t,factor)
  fx,tx,tst=tSt(x,fSamp,t,factor)
  fx,tx,tdst=tdSt(x,fSamp,t,factor)

  omega = 1j*dst/st
  tau = tst/st

  q = -1j * (ddst*st - dst*dst)/(tst*dst - tdst*st)

  omega2 = omega + q * tau

  se = np.where(np.fix (np.abs(omega2)) <= threshold , st, 0.0) 

  return tx,fx,st,se